//@version=6
// build 2025-06-10_2.4.4 (corrigido: variáveis, scope, tipos e placeholders)
// SciFib_H1 Stepwise: placeholders fixos, filtros unificados, sem vazamento de objetos.
indicator("tabelaEsn,Fractal,zonas", shorttitle="PRINCIPAL-facfib", overlay=true, max_lines_count=200, max_labels_count=200)

// ==================================================================
// 1. INPUTS (Top N pesos, parâmetros básicos e novos toggles)
// ==================================================================
showFractalPoints  = input.bool(true,   "Mostrar Fractais H1")
showFibLines       = input.bool(true,   "Mostrar Linhas Fibonacci")
showZones          = input.bool(true,   "Mostrar Zonas de Confluência")

atrLength          = input.int(14,      "Comprimento do ATR",                  minval=5)
atrMultiplier      = input.float(1.5,   "Multiplicador do ATR",                step=0.1, minval=0.5, maxval=3)
minSignificance    = input.float(1.0,   "Significância Mínima (peso)",         step=0.01, minval=0.0)

n                  = input.int(5,       "Período do Fractal (n)",              minval=1, maxval=10)
maxFractalsToCheck = input.int(50,      "Máx. Fractais a Checar",              minval=1)

topN               = input.int(0,       "Mostrar Top N Níveis (0=OFF)",        minval=0, maxval=10)

// Novos inputs solicitados
autoHideLow        = input.bool(false,  "Auto‐Hide Low Weights em TF ≤ X")                 // habilita/ desabilita filtro de peso baixo
tfHideThresh       = input.int(60,      "TF Limite para Auto‐Hide (minutos)",  minval=1)   // em minutos
weightMinPct       = input.float(0.50,  "Peso Mínimo (%) para mostrar nível",  minval=0.0, maxval=1.0, step=0.01)

replayMode         = input.bool(false,  "Replay Step by Step (mostrar apenas último swing)")

// Para futura expansão (replayCount), mas atualmente não usado:
replayCount        = input.int(1,       "Quantos Swings Exibir no Replay",     minval=1)

// ==================================================================
// 2. CÁLCULO DE ATR, MÉDIA E VOLATILIDADE (H1)
// ==================================================================
atrValue    = ta.ema(ta.atr(atrLength), 10)
h1CloseArr  = request.security(syminfo.tickerid, "60", close)
h1Mean      = ta.sma(h1CloseArr, 50)
h1Stdev     = ta.stdev(h1CloseArr, 50)
volPctRaw   = request.security(syminfo.tickerid, "60", ta.stdev(close, 50) / ta.sma(close, 50))
volPct      = volPctRaw > 0 ? volPctRaw : 0.0

// ==================================================================
// 3. ARRAYS E VARIÁVEIS PARA FRACTAIS E FIBONACCI
// ==================================================================
var float[] fractalPrices   = array.new_float()   // preços únicos de fractais
var int[]   fractalTouches  = array.new_int()     // contagem de toques em cada fractal
var label[] fractalPointLabels = array.new_label()  // armazena labels de fractais

var float[] fibLevels       = array.from(0.0, 0.236, 0.382, 0.5, 0.618, 0.786, 1.0, 1.272, 1.618, 2.0)
levelsCount                 = array.size(fibLevels)              // total de níveis Fibonacci
var float[] fibPrices       = array.new_float(levelsCount, 0.0)  // preços de cada nível
var float[] fibWeights      = array.new_float(levelsCount, 0.0)  // pesos (weight) de cada nível

// Placeholders fixos (criados apenas uma vez)
var  line[]    fibLines     = array.new_line()        // linhas de Fibonacci (levelsCount)
var label[]   fibLabels     = array.new_label()       // labels de “% | Peso” (levelsCount)
var label[]   circleLabels  = array.new_label()       // Labels-círculo (levelsCount)

var line[]    zoneLinesLow   = array.new_line()       // linha inferior de cada zona (levelsCount)
var line[]    zoneLinesHigh  = array.new_line()       // linha superior de cada zona (levelsCount)
var linefill[] zoneFills     = array.new_linefill()   // linefills para zonas (levelsCount)

var float lastHigh = na   // último pivot high (H1)
var float lastLow  = na   // último pivot low (H1)

// Variável global para armazenar, a cada swing, o maxWeight calculado
var float lastMaxWeight = 0.0

// Variáveis de “replay” de swings
var int[]   swingBars   = array.new_int()  // armazena bar_index de cada swing detectado
var int     swingsCount = 0                // contador de swings detectados

// ==================================================================
// 4. TABELA DE STATUS (PARÂMETROS)
// ==================================================================
var table tableStatus = table.new(position.top_right, 2, 7, bgcolor=color.rgb(120, 123, 134, 39), border_color=color.gray, frame_color=color.gray)
if barstate.isfirst
    // Cabeçalhos
    table.cell(tableStatus, 0, 0, "Parâmetro",            bgcolor=color.new(color.blue, 30), text_color=color.white)
    table.cell(tableStatus, 1, 0, "Valor Atual",          bgcolor=color.new(color.blue, 30), text_color=color.white)
    table.cell(tableStatus, 0, 2, "Multiplicador ATR",    text_color=color.white)
    table.cell(tableStatus, 0, 3, "Volatilidade H1 (%)",  text_color=color.white)
    table.cell(tableStatus, 0, 4, "Signif. Mín (peso)",   text_color=color.white)
    table.cell(tableStatus, 0, 5, "Período Fractal (n)",  text_color=color.white)
    table.cell(tableStatus, 0, 6, "Top N Níveis",         text_color=color.white)

string atrTxt   = "ATR(" + str.tostring(atrLength) + ")"
string atrVal   = str.tostring(atrValue, "#.##")
string multTxt  = str.tostring(atrMultiplier, "#.##")
string volTxt   = str.tostring(volPct * 100, "#.##") + "%"
string zTxt     = str.tostring(minSignificance, "#.##")
string nTxt     = str.tostring(n)
string topNTxt  = str.tostring(topN)

// Cor para TopN na tabela (cinza se 0, azul se >0)
color topNColor = (topN == 0) ? color.new(color.white, 50) : color.new(color.blue, 0)

table.cell(tableStatus, 0, 1, atrTxt,   text_color=color.white)
table.cell(tableStatus, 1, 1, atrVal,   text_color=color.white)
table.cell(tableStatus, 1, 2, multTxt,  text_color=color.white)
table.cell(tableStatus, 1, 3, volTxt,   text_color=color.white)
table.cell(tableStatus, 1, 4, zTxt,     text_color=color.yellow)
table.cell(tableStatus, 1, 5, nTxt,     text_color=color.white)
table.cell(tableStatus, 1, 6, topNTxt,  text_color=topNColor)

// ==================================================================
// 5. FUNÇÃO PARA CALCULAR Z-SCORE (DISTÂNCIA AO PREÇO MÉDIO H1)
// ==================================================================
calcZscore(_price) => h1Stdev > 0 ? math.abs(_price - h1Mean) / h1Stdev : 1.0

// ==================================================================
// 6. FUNÇÃO PARA ADICIONAR UM FRACTAL (EVITA DUPLICATAS PRÓXIMAS)
// ==================================================================
addFractal(_price) =>
    bool isDup    = false
    float gapATR  = atrValue * 0.5                  // distância mínima = 0.5 ATR
    float gapVol  = volPct * _price * atrMultiplier // distância mínima = volatilidade%
    float gapMin  = math.max(gapATR, gapVol)

    int startIdx = math.max(0, array.size(fractalPrices) - maxFractalsToCheck)
    if array.size(fractalPrices) > 0
        for i = startIdx to array.size(fractalPrices) - 1
            if math.abs(_price - array.get(fractalPrices, i)) < gapMin
                isDup := true
                break

    if not isDup
        array.push(fractalPrices, _price)
        array.push(fractalTouches, 0)

// ==================================================================
// 7. COLETA DE FRACTAIS H1 (pivot high/low)
// ==================================================================
ph = request.security(syminfo.tickerid, "60", ta.pivothigh(high, n, n))
pl = request.security(syminfo.tickerid, "60", ta.pivotlow(low, n, n))

if not na(ph)
    addFractal(ph)
if not na(pl)
    addFractal(pl)

// ==================================================================
// 8. CONTAGEM DE TOQUES DE FRACTAL NO TF H1 CONFIRMADO
// ==================================================================
if timeframe.isminutes and timeframe.multiplier == 60 and barstate.isconfirmed and array.size(fractalPrices) > 0
    int startIdx2 = math.max(0, array.size(fractalPrices) - maxFractalsToCheck)
    for i = startIdx2 to array.size(fractalPrices) - 1
        float fp = array.get(fractalPrices, i)
        if high >= fp and low <= fp
            array.set(fractalTouches, i, array.get(fractalTouches, i) + 1)

// ==================================================================
// 9. PLOTAGEM DOS PONTOS DE FRACTAL (APENAS EM TF = H1)
// ==================================================================
if showFractalPoints
    // apenas plota quando ph/pl corresponde a um dos últimos N valores registrados
    if not na(ph)
        float offsetTicksHigh = syminfo.mintick * 10
        int tph = request.security(syminfo.tickerid, "60", time[n])
        label lb = label.new( x = tph, y = ph + offsetTicksHigh, text = "▲", xloc = xloc.bar_time, yloc = yloc.price, color = color.new(color.green, 0), textcolor = color.white, size = size.tiny)
        array.push(fractalPointLabels, lb)
        if array.size(fractalPointLabels) > maxFractalsToCheck
            label.delete(array.shift(fractalPointLabels))
    if not na(pl)
        float offsetTicksLow = syminfo.mintick * 10
        int tpl = request.security(syminfo.tickerid, "60", time[n])
        label lb2 = label.new( x = tpl, y = pl - offsetTicksLow, text = "▼", xloc = xloc.bar_time, yloc = yloc.price, color = color.new(color.red, 0), textcolor = color.white, size = size.tiny)
        array.push(fractalPointLabels, lb2)
        if array.size(fractalPointLabels) > maxFractalsToCheck
            label.delete(array.shift(fractalPointLabels))
// ==================================================================
// 10. ATUALIZAÇÃO DE ÚLTIMOS SWINGS (HIGH / LOW) + “Replay”
// ==================================================================
float prevHigh = lastHigh[1]
float prevLow  = lastLow[1]

if not na(ph)
    if ph != prevHigh
        swingsCount += 1
        array.push(swingBars, bar_index)
    lastHigh := ph

if not na(pl)
    if pl != prevLow
        swingsCount += 1
        array.push(swingBars, bar_index)
    lastLow := pl

bool doAutoHide = autoHideLow and timeframe.isminutes and timeframe.multiplier <= tfHideThresh
int  currentSwingIdx = swingsCount > 0 ? swingsCount - 1 : 0

// ==================================================================
// 11. CRIAÇÃO ÚNICA DE PLACEHOLDERS (apenas na primeira barra)
// ==================================================================
if barstate.isfirst
    // (A) Placeholders para linhas Fibonacci, labels e círculos
    for i = 0 to levelsCount - 1
        // 1) Linha cinza quase invisível
        line phline = line.new(x1 = bar_index, y1 = 0, x2 = bar_index + 1, y2 = 0, xloc = xloc.bar_index, extend = extend.right, color = color.new(color.gray, 80), width = 1, style = line.style_dotted)

        // 2) Label “% | Peso” invisível (texto vazio, cor cinza total)
        label flabel = label.new( x = bar_index + 1, y = 0, text = "", xloc = xloc.bar_index, yloc = yloc.price, style = label.style_label_left, color = color.new(color.gray, 100), textcolor = color.white, size = size.small)

        // 3) Círculo invisível
        label clabel = label.new(x = bar_index, y = 0, text = "", xloc = xloc.bar_index, yloc = yloc.price,style = label.style_circle, size = size.small, color = color.new(color.gray, 100))

        array.push(circleLabels, clabel)
        array.push(fibLabels, flabel)
        array.push(fibLines, phline)

    // (B) Placeholders para zonas (linhas + linefill) – invisíveis em y = 0
    for i = 0 to levelsCount - 1
        line l1p = line.new( x1     = bar_index, y1 = 0,x2     = bar_index + 1, y2 = 0, xloc   = xloc.bar_index, extend = extend.right,color  = color.new(color.blue, 98), width = 1)
        line l2p = line.new(x1     = bar_index, y1 = 0,x2     = bar_index + 1, y2 = 0,xloc   = xloc.bar_index, extend = extend.right,color  = color.new(color.blue, 98), width = 1)

        array.push(zoneLinesLow,  l1p)
        array.push(zoneLinesHigh, l2p)
        array.push(zoneFills, linefill.new(l1p, l2p, color.new(color.blue, 98)))

// ==================================================================
// 12. SE HOUVER SWING VÁLIDO, CALCULA NÍVEIS DE FIBO, PESOS E DESENHA
// ==================================================================
float threshold = minSignificance
int[] topIndices = array.new_int()

if not na(lastHigh) and not na(lastLow)
    float topVal    = math.max(lastHigh, lastLow)
    float bottomVal = math.min(lastHigh, lastLow)
    float rangeVal  = topVal - bottomVal

    for i = 0 to levelsCount - 1
        float lvlFrac  = array.get(fibLevels, i)
        float lvlPrice = bottomVal + rangeVal * lvlFrac
        array.set(fibPrices, i, lvlPrice)

    // ==================================================================
    // 12.A) CÁLCULO DE “weight” E maxWeight
    // ==================================================================
    float maxWeight = 0.0
    int   startIdx3 = math.max(0, array.size(fractalPrices) - maxFractalsToCheck)

    for i = 0 to levelsCount - 1
        float priceF      = array.get(fibPrices, i)
        float distPctCalc = volPct * priceF * atrMultiplier
        int   contagem    = 0

        // Conta quantos fractais caem dentro da “zona” deste nível
        for j = startIdx3 to array.size(fractalPrices) - 1
            float fp = array.get(fractalPrices, j)
            if math.abs(fp - priceF) <= distPctCalc
                contagem += 1

        float z      = calcZscore(priceF)
        float weight = contagem > 0 ? (contagem + 1) * math.log(z + 1) : 0.0
        array.set(fibWeights, i, weight)

        if weight > maxWeight
            maxWeight := weight

    // Atribui o valor de maxWeight a lastMaxWeight, para usar depois na tabela/filtros
    lastMaxWeight := maxWeight

    // ==================================================================
    // 12.B) DETERMINAR “topIndices” SE topN > 0
    // ==================================================================
    if topN > 0
        // (a) copiar fibWeights para tempWeights
        float[] tempWeights = array.new_float()
        for k = 0 to levelsCount - 1
            array.push(tempWeights, array.get(fibWeights, k))

        // (b) encontrar os topN maiores
        int limit = math.min(topN, levelsCount)
        for t = 0 to limit - 1
            float bestW = -1.0
            int   idxMax = 0

            for m = 0 to levelsCount - 1
                float w = array.get(tempWeights, m)
                if w > bestW
                    bestW := w
                    idxMax := m

            if bestW < minSignificance
                break

            array.push(topIndices, idxMax)
            array.set(tempWeights, idxMax, -1.0)

        // (c) atualizar threshold para o N-ésimo maior peso
        if array.size(topIndices) > 0
            int lastIx = array.get(topIndices, array.size(topIndices) - 1)
            threshold := array.get(fibWeights, lastIx)
        else
            threshold := minSignificance

    // ==================================================================
    // 12.C) REAPROVEITAMENTO DE PLACEHOLDERS PARA LINHAS FIBONACCI, CÍRCULOS E LABELS
    // ==================================================================
    if showFibLines and maxWeight > 0
        for i = 0 to levelsCount - 1
            line ln        = array.get(fibLines, i)
            label fpLabel  = array.get(fibLabels, i)
            label circLbl  = array.get(circleLabels, i)
            float priceF   = array.get(fibPrices, i)
            float weight   = array.get(fibWeights, i)
            float lvlFrac  = array.get(fibLevels, i)
            float pctW     = (lastMaxWeight > 0) ? (weight / lastMaxWeight) : 0.0

            // ==== FILTROS ====
            bool validLevel = true

            // (A) ReplayMode: só desenha após pivot confirm
            if replayMode and array.size(swingBars) > 0
                int swingBarIdx = array.get(swingBars, currentSwingIdx)
                if bar_index < swingBarIdx
                    validLevel := false

            // (B) Auto-Hide: TF baixo + peso muito baixo
            if validLevel and doAutoHide and pctW < weightMinPct
                validLevel := false

            // (C) TopN ou threshold
            if validLevel and topN > 0 and not array.includes(topIndices, i)
                validLevel := false
            
            if validLevel and topN == 0 and weight < threshold
                validLevel := false

            if not validLevel
                // Esconde linha, label e círculo
                line.set_extend(ln, extend.none)
                label.set_xy(   fpLabel,  bar_index + 1, priceF )
                label.set_text( fpLabel,  "" )
                label.set_color(fpLabel,  color.new(color.gray, 100))
                label.set_color(circLbl,  color.new(color.gray, 100))
                continue

            // ==== COR E ESTILO ====
            bool isTop    = (weight == lastMaxWeight)
            bool isHigh   = (weight >= lastMaxWeight * 0.75) and not isTop
            bool isMedium = (weight >= lastMaxWeight * 0.50) and not (isTop or isHigh)

            color baseColor = isTop    ? color.red : isHigh   ? color.yellow : isMedium ? color.green : color.new(color.blue, 80)
            int lw = isTop  ? 3 : isHigh ? 2 : 1

            styleLine = (isTop or lvlFrac == 0.0 or lvlFrac == 1.0) ? line.style_solid : line.style_dotted

            // (1) Reposiciona e pinta a linha
            line.set_xy1( ln, bar_index,      priceF )
            line.set_xy2( ln, bar_index + 1,  priceF )
            line.set_color( ln, baseColor )
            line.set_width( ln, lw )
            line.set_style( ln, styleLine )
            line.set_extend( ln, extend.right )

            // (2) Label “% | Peso”
            float pct = (rangeVal > 0) ? math.round(100 * (priceF - bottomVal) / rangeVal, 2) : na
            string txtW = str.tostring(pct, "#.##") + "% | Peso: " + str.tostring(weight, "#.##")
            label.set_xy(   fpLabel,  bar_index + 1, priceF )
            label.set_text( fpLabel,  txtW )
            label.set_color(fpLabel,  color.new(baseColor, 30))

            // (3) Círculo (se peso > 50%)
            if weight > lastMaxWeight * 0.50
                int sizeC = math.round(5 * (weight / lastMaxWeight)) + 1  // escala 1..6
                label.set_xy(   circLbl, bar_index - 1, priceF )
                label.set_style(circLbl, label.style_circle)
                label.set_size( circLbl, sizeC )
                label.set_color(circLbl, color.new(baseColor, 70))
            else
                // esconde o círculo
                label.set_color(circLbl, color.new(color.gray, 100))

    // ==================================================================
    // 12.D) REAPROVEITAMENTO DE PLACEHOLDERS PARA ZONAS DE CONFLUÊNCIA
    // ==================================================================
    if showZones
        for i = 0 to levelsCount - 1
            linefill lf     = array.get(zoneFills, i)
            line    l1p     = array.get(zoneLinesLow,  i)
            line    l2p     = array.get(zoneLinesHigh, i)

            float priceF   = array.get(fibPrices, i)
            float weight   = array.get(fibWeights, i)
            float distPct  = volPct * priceF * atrMultiplier
            float lowZone  = priceF - distPct
            float highZone = priceF + distPct
            float pctW     = (lastMaxWeight > 0) ? (weight / lastMaxWeight) : 0.0

            // ==== FILTROS ====
            bool validZone = true

            if replayMode and array.size(swingBars) > 0
                int swingBarIdx = array.get(swingBars, currentSwingIdx)
                if bar_index < swingBarIdx
                    validZone := false

            if validZone and doAutoHide and pctW < weightMinPct
                validZone := false

            if validZone and topN > 0 and not array.includes(topIndices, i)
                validZone := false

            if validZone and topN == 0 and weight < threshold
                validZone := false

            if not validZone
                // esconde a zona mantendo fills invisíveis
                line.set_extend(l1p, extend.none)
                line.set_extend(l2p, extend.none)
                linefill.set_color(lf, color.new(color.blue, 98))
                continue

            // ==== COR E ESTILO ====
            bool isTop    = (weight == lastMaxWeight)
            bool isHigh   = (weight >= lastMaxWeight * 0.75) and not isTop
            bool isMedium = (weight >= lastMaxWeight * 0.50) and not (isTop or isHigh)

            color borderColor = isTop ? color.red : isHigh   ? color.yellow : isMedium ? color.green : color.blue
            color fillColor   = isTop ? color.new(color.red, 80) : isHigh   ? color.new(color.yellow, 80) : isMedium ? color.new(color.green, 80) : color.new(color.blue, 80)

            // (1) Move bordas da zona
            line.set_xy1( l1p, bar_index,     lowZone )
            line.set_xy2( l1p, bar_index + 1, lowZone )
            line.set_xy1( l2p, bar_index,     highZone )
            line.set_xy2( l2p, bar_index + 1, highZone )
            line.set_color( l1p, color.new(borderColor, 60) )
            line.set_color( l2p, color.new(borderColor, 60) )
            line.set_extend(l1p, extend.right)
            line.set_extend(l2p, extend.right)

            // (2) Atualiza o fill
            linefill.set_color(lf, fillColor)

// ==================================================================
// 13. TABELA AUXILIAR DE “PROVA DE WEIGHT” (Top N / Z-score / Incluído?)
// ==================================================================
var table tableWeights = table.new(position.top_left, 5, levelsCount + 1, bgcolor=color.new(color.black, 65), frame_color=color.rgb(78, 82, 94))

if barstate.islast
    // Cabeçalhos
    table.cell(tableWeights, 0, 0, "Nível (%)",  text_color=color.white, bgcolor=color.new(color.blue, 30))
    table.cell(tableWeights, 1, 0, "# Fractais", text_color=color.white, bgcolor=color.new(color.blue, 30))
    table.cell(tableWeights, 2, 0, "Z-score",    text_color=color.white, bgcolor=color.new(color.blue, 30))
    table.cell(tableWeights, 3, 0, "Peso",       text_color=color.white, bgcolor=color.new(color.blue, 30))
    table.cell(tableWeights, 4, 0, "Incluído?",  text_color=color.white, bgcolor=color.new(color.blue, 30))

    for i = 0 to levelsCount - 1
        float lvlFrac  = array.get(fibLevels, i)
        float priceF   = array.get(fibPrices, i)
        float distPct  = volPct * priceF * atrMultiplier
        int cont       = 0

        // Recalcula contagem para tabela
        for j = math.max(0, array.size(fractalPrices) - maxFractalsToCheck) to array.size(fractalPrices) - 1
            if math.abs(array.get(fractalPrices, j) - priceF) <= distPct
                cont += 1

        float zVal = calcZscore(priceF)
        float wt   = array.get(fibWeights, i)
        float pctWeightTbl = lastMaxWeight > 0 ? (wt / lastMaxWeight) : 0.0

        // Verifica se está incluído (mesmos filtros de 12.C e 12.D)
        bool isIncluded = true

        // (A) ReplayMode
        if replayMode and array.size(swingBars) > 0
            int swingBarIdx = array.get(swingBars, currentSwingIdx)
            if bar_index < swingBarIdx
                isIncluded := false

        // (B) Auto-Hide
        if isIncluded and doAutoHide and pctWeightTbl < weightMinPct
            isIncluded := false

        // (C) TopN
        if isIncluded and topN > 0 and not array.includes(topIndices, i)
            isIncluded := false

        // (D) Threshold (quando topN == 0)
        if isIncluded and topN == 0 and wt < threshold
            isIncluded := false

        string nivelTxt = str.tostring(lvlFrac * 100, "#.##") + "%"
        string inclTxt  = isIncluded ? "Sim" : "Não"

        // Células: Nível (%), # Fractais, Z-score, Peso, Incluído?
        table.cell(tableWeights, 0, i + 1, nivelTxt,           text_color=color.white)
        table.cell(tableWeights, 1, i + 1, str.tostring(cont), text_color=color.white)
        table.cell(tableWeights, 2, i + 1, str.tostring(zVal, "#.##"), text_color=color.white)

        color cellBg = (wt == lastMaxWeight) ? color.new(color.red, 50) : (wt >= lastMaxWeight * 0.75) ? color.new(color.yellow, 50) : (wt >= lastMaxWeight * 0.50) ? color.new(color.green, 50) : color.new(color.blue, 80)

        table.cell(tableWeights, 3, i + 1, str.tostring(wt, "#.##"),text_color = color.white, bgcolor = cellBg)
        table.cell(tableWeights, 4, i + 1, inclTxt, text_color = color.white)

// ==================================================================
// FIM DO v2.4.4 (placeholders fixos, filtros unificados, sem vazamento)
// ==================================================================
